/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * file.proto
 * OpenAPI spec version: version not set
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './mutator';
import type { ErrorType } from './mutator';
export type PostToggleAction = typeof PostToggleAction[keyof typeof PostToggleAction];


export const PostToggleAction = {
  TOGGLE_ACTION_UNSPECIFIED: 'TOGGLE_ACTION_UNSPECIFIED',
  TOGGLE_ACTION_ADD: 'TOGGLE_ACTION_ADD',
  TOGGLE_ACTION_REMOVE: 'TOGGLE_ACTION_REMOVE',
} as const;

export interface PostServiceCollectPostBody {
  action?: PostToggleAction;
}

export interface PostServiceLikePostBody {
  action?: PostToggleAction;
}

export interface PostServiceUpdatePostBody {
  text?: string;
  images?: string[];
  attachments?: string[];
  tags?: string[];
  visibility?: string;
  pinned?: boolean;
}

export interface UserServiceUpdateUserBody {
  username?: string;
  email?: string;
  nickname?: string;
  avatarUrl?: string;
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }
    // or ...
    if (any.isSameTypeAs(Foo.getDefaultInstance())) {
      foo = any.unpack(Foo.getDefaultInstance());
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".

JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    }
 */
export interface ProtobufAny {
  /** A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one "/" character. The last segment of the URL's path must represent
the fully qualified name of the type (as in
`path/google.protobuf.Duration`). The name should be in a canonical form
(e.g., leading "." is not accepted).

In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme `http`, `https`, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:

* If no scheme is provided, `https` is assumed.
* An HTTP GET on the URL must yield a [google.protobuf.Type][]
  value in binary format, or produce an error.
* Applications are allowed to cache lookup results based on the
  URL, or have them precompiled into a binary to avoid any
  lookup. Therefore, binary compatibility needs to be preserved
  on changes to types. (Use versioned type names to manage
  breaking changes.)

Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com. As of May 2023, there are no widely used type server
implementations and no plans to implement one.

Schemes other than `http`, `https` (or the empty scheme) might be
used with implementation specific semantics. */
  '@type'?: string;
  [key: string]: unknown;
}

/**
 * Message that represents an arbitrary HTTP body. It should only be used for
payload formats that can't be represented as JSON, such as raw binary or
an HTML page.


This message can be used both in streaming and non-streaming API methods in
the request as well as the response.

It can be used as a top-level request field, which is convenient if one
wants to extract parameters from either the URL or HTTP template into the
request fields and also want access to the raw HTTP body.

Example:

    message GetResourceRequest {
      // A unique request id.
      string request_id = 1;

      // The raw HTTP body is bound to this field.
      google.api.HttpBody http_body = 2;

    }

    service ResourceService {
      rpc GetResource(GetResourceRequest)
        returns (google.api.HttpBody);
      rpc UpdateResource(google.api.HttpBody)
        returns (google.protobuf.Empty);

    }

Example with streaming methods:

    service CaldavService {
      rpc GetCalendar(stream google.api.HttpBody)
        returns (stream google.api.HttpBody);
      rpc UpdateCalendar(stream google.api.HttpBody)
        returns (stream google.api.HttpBody);

    }

Use of this type only changes how the request and response bodies are
handled, all other features will continue to work unchanged.
 */
export interface ApiHttpBody {
  /** The HTTP Content-Type header value specifying the content type of the body. */
  contentType?: string;
  /** The HTTP request/response body as raw binary. */
  data?: string;
  /** Application specific response metadata. Must be set in the first response
for streaming APIs. */
  extensions?: ProtobufAny[];
}

export interface FileFile {
  readonly name: string;
  readonly contentType: string;
  readonly size: string;
  readonly checksum: string;
  readonly uploader: string;
  readonly createdAt: string;
}

export interface FileGetFileMetaResponse {
  readonly file: FileFile;
  readonly url: string;
}

export interface FileUploadFileRequest {
  name?: string;
  contentType?: string;
  data?: string;
  checksum?: string;
}

export interface FileUploadFileResponse {
  readonly file: FileFile;
  readonly url: string;
}

export interface PostAttachment {
  readonly url: string;
  readonly name: string;
  readonly size: string;
  readonly contentType: string;
  readonly checksum: string;
}

export interface PostCreatePostRequest {
  text?: string;
  images?: string[];
  attachments?: string[];
  tags?: string[];
  visibility?: string;
  pinned?: boolean;
}

export interface PostCreatePostResponse {
  readonly uid: string;
}

export interface PostPostAuthor {
  readonly uid: string;
  readonly nickname: string;
  readonly avatarUrl: string;
}

export interface PostPost {
  readonly uid: string;
  readonly author: PostPostAuthor;
  readonly text: string;
  readonly images: readonly string[];
  readonly attachments: readonly PostAttachment[];
  readonly tags: readonly string[];
  readonly commentCount: string;
  readonly collectionCount: string;
  readonly likeCount: string;
  readonly visibility: string;
  readonly latestRepliedOn: string;
  readonly ip: string;
  readonly pinned: boolean;
  readonly createdAt: string;
  readonly updatedAt: string;
}

export interface PostGetPostResponse {
  readonly post: PostPost;
}

export interface PostListPostsResponse {
  readonly posts: readonly PostPost[];
  readonly nextPageToken: string;
  readonly totalSize: string;
}

export interface RpcStatus {
  code?: number;
  message?: string;
  details?: ProtobufAny[];
}

export interface UserChangePasswordRequest {
  oldPassword?: string;
  newPassword?: string;
}

export interface UserCreateUserRequest {
  username?: string;
  password?: string;
  email?: string;
  nickname?: string;
}

export interface UserUser {
  readonly uid: string;
  readonly username: string;
  readonly role: string;
  readonly email: string;
  readonly nickname: string;
  readonly avatarUrl: string;
}

export interface UserGetMeResponse {
  readonly user: UserUser;
}

export interface UserGetUserResponse {
  readonly user: UserUser;
}

export interface UserListUsersResponse {
  readonly users: readonly UserUser[];
  readonly nextPageToken: string;
  readonly totalSize: string;
}

export interface UserLoginRequest {
  account?: string;
  password?: string;
  captcha?: string;
  deviceId?: string;
}

export interface UserTokenPair {
  readonly accessToken: string;
  readonly refreshToken: string;
}

export interface UserLoginResponse {
  readonly tokens: UserTokenPair;
}

export interface UserRefreshTokenRequest {
  refreshToken?: string;
}

export interface UserRefreshTokenResponse {
  readonly tokens: UserTokenPair;
}

export interface UserUpdateMeRequest {
  username?: string;
  email?: string;
  nickname?: string;
  avatarUrl?: string;
}

export interface UserUpdateUserResponse {
  readonly user: UserUser;
}

export type UserServiceUpdateMe200 = { [key: string]: unknown };

export type PostServiceListMyCollectionsParams = {
pageSize?: number;
pageToken?: string;
author?: string;
tag?: string;
visibility?: string;
search?: string;
};

export type UserServiceChangePassword200 = { [key: string]: unknown };

export type PostServiceListMyPostsParams = {
pageSize?: number;
pageToken?: string;
author?: string;
tag?: string;
visibility?: string;
search?: string;
};

export type PostServiceListPostsParams = {
pageSize?: number;
pageToken?: string;
author?: string;
tag?: string;
visibility?: string;
search?: string;
};

export type PostServiceDeletePost200 = { [key: string]: unknown };

export type PostServiceUpdatePost200 = { [key: string]: unknown };

export type PostServiceCollectPost200 = { [key: string]: unknown };

export type PostServiceLikePost200 = { [key: string]: unknown };

export type UserServiceListUsersParams = {
pageSize?: number;
pageToken?: string;
filter?: string;
orderBy?: string;
};

export type UserServiceCreateUser200 = { [key: string]: unknown };

export type UserServiceDeleteUser200 = { [key: string]: unknown };

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary POST /api/v1/auth/login ÁôªÂΩï
 */
export const userServiceLogin = (
    userLoginRequest: UserLoginRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserLoginResponse>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLoginRequest, signal
    },
      options);
    }
  


export const getUserServiceLoginMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceLogin>>, TError,{data: UserLoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userServiceLogin>>, TError,{data: UserLoginRequest}, TContext> => {

const mutationKey = ['userServiceLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userServiceLogin>>, {data: UserLoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  userServiceLogin(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UserServiceLoginMutationResult = NonNullable<Awaited<ReturnType<typeof userServiceLogin>>>
    export type UserServiceLoginMutationBody = UserLoginRequest
    export type UserServiceLoginMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/auth/login ÁôªÂΩï
 */
export const useUserServiceLogin = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceLogin>>, TError,{data: UserLoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userServiceLogin>>,
        TError,
        {data: UserLoginRequest},
        TContext
      > => {
      return useMutation(getUserServiceLoginMutationOptions(options), queryClient);
    }
    
/**
 * @summary POST /api/v1/auth/refresh Âà∑Êñ∞ token
 */
export const userServiceRefreshToken = (
    userRefreshTokenRequest: UserRefreshTokenRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRefreshTokenResponse>(
      {url: `/api/v1/auth/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userRefreshTokenRequest, signal
    },
      options);
    }
  


export const getUserServiceRefreshTokenMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceRefreshToken>>, TError,{data: UserRefreshTokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userServiceRefreshToken>>, TError,{data: UserRefreshTokenRequest}, TContext> => {

const mutationKey = ['userServiceRefreshToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userServiceRefreshToken>>, {data: UserRefreshTokenRequest}> = (props) => {
          const {data} = props ?? {};

          return  userServiceRefreshToken(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UserServiceRefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof userServiceRefreshToken>>>
    export type UserServiceRefreshTokenMutationBody = UserRefreshTokenRequest
    export type UserServiceRefreshTokenMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/auth/refresh Âà∑Êñ∞ token
 */
export const useUserServiceRefreshToken = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceRefreshToken>>, TError,{data: UserRefreshTokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userServiceRefreshToken>>,
        TError,
        {data: UserRefreshTokenRequest},
        TContext
      > => {
      return useMutation(getUserServiceRefreshTokenMutationOptions(options), queryClient);
    }
    
/**
 * @summary POST /api/v1/files ‰∏ä‰º†Êñá‰ª∂
 */
export const fileServiceUploadFile = (
    fileUploadFileRequest: FileUploadFileRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FileUploadFileResponse>(
      {url: `/api/v1/files`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fileUploadFileRequest, signal
    },
      options);
    }
  


export const getFileServiceUploadFileMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileServiceUploadFile>>, TError,{data: FileUploadFileRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof fileServiceUploadFile>>, TError,{data: FileUploadFileRequest}, TContext> => {

const mutationKey = ['fileServiceUploadFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof fileServiceUploadFile>>, {data: FileUploadFileRequest}> = (props) => {
          const {data} = props ?? {};

          return  fileServiceUploadFile(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FileServiceUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof fileServiceUploadFile>>>
    export type FileServiceUploadFileMutationBody = FileUploadFileRequest
    export type FileServiceUploadFileMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/files ‰∏ä‰º†Êñá‰ª∂
 */
export const useFileServiceUploadFile = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileServiceUploadFile>>, TError,{data: FileUploadFileRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof fileServiceUploadFile>>,
        TError,
        {data: FileUploadFileRequest},
        TContext
      > => {
      return useMutation(getFileServiceUploadFileMutationOptions(options), queryClient);
    }
    
/**
 * @summary GET /api/v1/files/content/{url} Ëé∑ÂèñÊñá‰ª∂ÂÜÖÂÆπ
 */
export const fileServiceGetFile = (
    url: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiHttpBody>(
      {url: `/api/v1/files/content/${url}`, method: 'GET', signal
    },
      options);
    }
  



export const getFileServiceGetFileQueryKey = (url: string,) => {
    return [
    `/api/v1/files/content/${url}`
    ] as const;
    }

    
export const getFileServiceGetFileQueryOptions = <TData = Awaited<ReturnType<typeof fileServiceGetFile>>, TError = ErrorType<RpcStatus>>(url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFileServiceGetFileQueryKey(url);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fileServiceGetFile>>> = ({ signal }) => fileServiceGetFile(url, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(url), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FileServiceGetFileQueryResult = NonNullable<Awaited<ReturnType<typeof fileServiceGetFile>>>
export type FileServiceGetFileQueryError = ErrorType<RpcStatus>


export function useFileServiceGetFile<TData = Awaited<ReturnType<typeof fileServiceGetFile>>, TError = ErrorType<RpcStatus>>(
 url: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileServiceGetFile>>,
          TError,
          Awaited<ReturnType<typeof fileServiceGetFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFileServiceGetFile<TData = Awaited<ReturnType<typeof fileServiceGetFile>>, TError = ErrorType<RpcStatus>>(
 url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileServiceGetFile>>,
          TError,
          Awaited<ReturnType<typeof fileServiceGetFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFileServiceGetFile<TData = Awaited<ReturnType<typeof fileServiceGetFile>>, TError = ErrorType<RpcStatus>>(
 url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/files/content/{url} Ëé∑ÂèñÊñá‰ª∂ÂÜÖÂÆπ
 */

export function useFileServiceGetFile<TData = Awaited<ReturnType<typeof fileServiceGetFile>>, TError = ErrorType<RpcStatus>>(
 url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFileServiceGetFileQueryOptions(url,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary GET /api/v1/files/meta/{url} Ëé∑ÂèñÊñá‰ª∂ÂÖÉÊï∞ÊçÆÔºà‰∏çÂê´ÂÜÖÂÆπÔºâ
 */
export const fileServiceGetFileMeta = (
    url: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FileGetFileMetaResponse>(
      {url: `/api/v1/files/meta/${url}`, method: 'GET', signal
    },
      options);
    }
  



export const getFileServiceGetFileMetaQueryKey = (url: string,) => {
    return [
    `/api/v1/files/meta/${url}`
    ] as const;
    }

    
export const getFileServiceGetFileMetaQueryOptions = <TData = Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError = ErrorType<RpcStatus>>(url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFileServiceGetFileMetaQueryKey(url);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fileServiceGetFileMeta>>> = ({ signal }) => fileServiceGetFileMeta(url, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(url), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FileServiceGetFileMetaQueryResult = NonNullable<Awaited<ReturnType<typeof fileServiceGetFileMeta>>>
export type FileServiceGetFileMetaQueryError = ErrorType<RpcStatus>


export function useFileServiceGetFileMeta<TData = Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError = ErrorType<RpcStatus>>(
 url: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileServiceGetFileMeta>>,
          TError,
          Awaited<ReturnType<typeof fileServiceGetFileMeta>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFileServiceGetFileMeta<TData = Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError = ErrorType<RpcStatus>>(
 url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileServiceGetFileMeta>>,
          TError,
          Awaited<ReturnType<typeof fileServiceGetFileMeta>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFileServiceGetFileMeta<TData = Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError = ErrorType<RpcStatus>>(
 url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/files/meta/{url} Ëé∑ÂèñÊñá‰ª∂ÂÖÉÊï∞ÊçÆÔºà‰∏çÂê´ÂÜÖÂÆπÔºâ
 */

export function useFileServiceGetFileMeta<TData = Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError = ErrorType<RpcStatus>>(
 url: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fileServiceGetFileMeta>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFileServiceGetFileMetaQueryOptions(url,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary GET /api/v1/me ÂΩìÂâçÁî®Êà∑
 */
export const userServiceGetMe = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserGetMeResponse>(
      {url: `/api/v1/me`, method: 'GET', signal
    },
      options);
    }
  



export const getUserServiceGetMeQueryKey = () => {
    return [
    `/api/v1/me`
    ] as const;
    }

    
export const getUserServiceGetMeQueryOptions = <TData = Awaited<ReturnType<typeof userServiceGetMe>>, TError = ErrorType<RpcStatus>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserServiceGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userServiceGetMe>>> = ({ signal }) => userServiceGetMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userServiceGetMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserServiceGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof userServiceGetMe>>>
export type UserServiceGetMeQueryError = ErrorType<RpcStatus>


export function useUserServiceGetMe<TData = Awaited<ReturnType<typeof userServiceGetMe>>, TError = ErrorType<RpcStatus>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userServiceGetMe>>,
          TError,
          Awaited<ReturnType<typeof userServiceGetMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserServiceGetMe<TData = Awaited<ReturnType<typeof userServiceGetMe>>, TError = ErrorType<RpcStatus>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userServiceGetMe>>,
          TError,
          Awaited<ReturnType<typeof userServiceGetMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserServiceGetMe<TData = Awaited<ReturnType<typeof userServiceGetMe>>, TError = ErrorType<RpcStatus>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/me ÂΩìÂâçÁî®Êà∑
 */

export function useUserServiceGetMe<TData = Awaited<ReturnType<typeof userServiceGetMe>>, TError = ErrorType<RpcStatus>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserServiceGetMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary PATCH /api/v1/me Êõ¥Êñ∞Ëá™Â∑±
 */
export const userServiceUpdateMe = (
    userUpdateMeRequest: UserUpdateMeRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserServiceUpdateMe200>(
      {url: `/api/v1/me`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateMeRequest, signal
    },
      options);
    }
  


export const getUserServiceUpdateMeMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceUpdateMe>>, TError,{data: UserUpdateMeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userServiceUpdateMe>>, TError,{data: UserUpdateMeRequest}, TContext> => {

const mutationKey = ['userServiceUpdateMe'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userServiceUpdateMe>>, {data: UserUpdateMeRequest}> = (props) => {
          const {data} = props ?? {};

          return  userServiceUpdateMe(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UserServiceUpdateMeMutationResult = NonNullable<Awaited<ReturnType<typeof userServiceUpdateMe>>>
    export type UserServiceUpdateMeMutationBody = UserUpdateMeRequest
    export type UserServiceUpdateMeMutationError = ErrorType<RpcStatus>

    /**
 * @summary PATCH /api/v1/me Êõ¥Êñ∞Ëá™Â∑±
 */
export const useUserServiceUpdateMe = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceUpdateMe>>, TError,{data: UserUpdateMeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userServiceUpdateMe>>,
        TError,
        {data: UserUpdateMeRequest},
        TContext
      > => {
      return useMutation(getUserServiceUpdateMeMutationOptions(options), queryClient);
    }
    
/**
 * @summary GET /api/v1/me/collections ÂΩìÂâçÁî®Êà∑Êî∂ËóèÁöÑÂ∏ñÂ≠êÂàóË°®
 */
export const postServiceListMyCollections = (
    params?: PostServiceListMyCollectionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostListPostsResponse>(
      {url: `/api/v1/me/collections`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getPostServiceListMyCollectionsQueryKey = (params?: PostServiceListMyCollectionsParams,) => {
    return [
    `/api/v1/me/collections`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getPostServiceListMyCollectionsQueryOptions = <TData = Awaited<ReturnType<typeof postServiceListMyCollections>>, TError = ErrorType<RpcStatus>>(params?: PostServiceListMyCollectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyCollections>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostServiceListMyCollectionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postServiceListMyCollections>>> = ({ signal }) => postServiceListMyCollections(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyCollections>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostServiceListMyCollectionsQueryResult = NonNullable<Awaited<ReturnType<typeof postServiceListMyCollections>>>
export type PostServiceListMyCollectionsQueryError = ErrorType<RpcStatus>


export function usePostServiceListMyCollections<TData = Awaited<ReturnType<typeof postServiceListMyCollections>>, TError = ErrorType<RpcStatus>>(
 params: undefined |  PostServiceListMyCollectionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyCollections>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceListMyCollections>>,
          TError,
          Awaited<ReturnType<typeof postServiceListMyCollections>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceListMyCollections<TData = Awaited<ReturnType<typeof postServiceListMyCollections>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListMyCollectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyCollections>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceListMyCollections>>,
          TError,
          Awaited<ReturnType<typeof postServiceListMyCollections>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceListMyCollections<TData = Awaited<ReturnType<typeof postServiceListMyCollections>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListMyCollectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyCollections>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/me/collections ÂΩìÂâçÁî®Êà∑Êî∂ËóèÁöÑÂ∏ñÂ≠êÂàóË°®
 */

export function usePostServiceListMyCollections<TData = Awaited<ReturnType<typeof postServiceListMyCollections>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListMyCollectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyCollections>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostServiceListMyCollectionsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary POST /api/v1/me/password ÊîπÂØÜÁ†Å
 */
export const userServiceChangePassword = (
    userChangePasswordRequest: UserChangePasswordRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserServiceChangePassword200>(
      {url: `/api/v1/me/password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userChangePasswordRequest, signal
    },
      options);
    }
  


export const getUserServiceChangePasswordMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceChangePassword>>, TError,{data: UserChangePasswordRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userServiceChangePassword>>, TError,{data: UserChangePasswordRequest}, TContext> => {

const mutationKey = ['userServiceChangePassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userServiceChangePassword>>, {data: UserChangePasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  userServiceChangePassword(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UserServiceChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof userServiceChangePassword>>>
    export type UserServiceChangePasswordMutationBody = UserChangePasswordRequest
    export type UserServiceChangePasswordMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/me/password ÊîπÂØÜÁ†Å
 */
export const useUserServiceChangePassword = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceChangePassword>>, TError,{data: UserChangePasswordRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userServiceChangePassword>>,
        TError,
        {data: UserChangePasswordRequest},
        TContext
      > => {
      return useMutation(getUserServiceChangePasswordMutationOptions(options), queryClient);
    }
    
/**
 * @summary GET /api/v1/me/posts ÂΩìÂâçÁî®Êà∑ÂèëÂ∏ÉÁöÑÂàóË°®ÔºàÂê´ PRIVATEÔºâ
 */
export const postServiceListMyPosts = (
    params?: PostServiceListMyPostsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostListPostsResponse>(
      {url: `/api/v1/me/posts`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getPostServiceListMyPostsQueryKey = (params?: PostServiceListMyPostsParams,) => {
    return [
    `/api/v1/me/posts`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getPostServiceListMyPostsQueryOptions = <TData = Awaited<ReturnType<typeof postServiceListMyPosts>>, TError = ErrorType<RpcStatus>>(params?: PostServiceListMyPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostServiceListMyPostsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postServiceListMyPosts>>> = ({ signal }) => postServiceListMyPosts(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostServiceListMyPostsQueryResult = NonNullable<Awaited<ReturnType<typeof postServiceListMyPosts>>>
export type PostServiceListMyPostsQueryError = ErrorType<RpcStatus>


export function usePostServiceListMyPosts<TData = Awaited<ReturnType<typeof postServiceListMyPosts>>, TError = ErrorType<RpcStatus>>(
 params: undefined |  PostServiceListMyPostsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceListMyPosts>>,
          TError,
          Awaited<ReturnType<typeof postServiceListMyPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceListMyPosts<TData = Awaited<ReturnType<typeof postServiceListMyPosts>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListMyPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceListMyPosts>>,
          TError,
          Awaited<ReturnType<typeof postServiceListMyPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceListMyPosts<TData = Awaited<ReturnType<typeof postServiceListMyPosts>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListMyPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/me/posts ÂΩìÂâçÁî®Êà∑ÂèëÂ∏ÉÁöÑÂàóË°®ÔºàÂê´ PRIVATEÔºâ
 */

export function usePostServiceListMyPosts<TData = Awaited<ReturnType<typeof postServiceListMyPosts>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListMyPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListMyPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostServiceListMyPostsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary GET /api/v1/me/posts/{uid} ÂΩìÂâçÁî®Êà∑ÁöÑÂ∏ñÂ≠êËØ¶ÊÉÖÔºàÂê´ PRIVATEÔºâ
 */
export const postServiceGetMyPost = (
    uid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostGetPostResponse>(
      {url: `/api/v1/me/posts/${uid}`, method: 'GET', signal
    },
      options);
    }
  



export const getPostServiceGetMyPostQueryKey = (uid: string,) => {
    return [
    `/api/v1/me/posts/${uid}`
    ] as const;
    }

    
export const getPostServiceGetMyPostQueryOptions = <TData = Awaited<ReturnType<typeof postServiceGetMyPost>>, TError = ErrorType<RpcStatus>>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetMyPost>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostServiceGetMyPostQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postServiceGetMyPost>>> = ({ signal }) => postServiceGetMyPost(uid, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postServiceGetMyPost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostServiceGetMyPostQueryResult = NonNullable<Awaited<ReturnType<typeof postServiceGetMyPost>>>
export type PostServiceGetMyPostQueryError = ErrorType<RpcStatus>


export function usePostServiceGetMyPost<TData = Awaited<ReturnType<typeof postServiceGetMyPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetMyPost>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceGetMyPost>>,
          TError,
          Awaited<ReturnType<typeof postServiceGetMyPost>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceGetMyPost<TData = Awaited<ReturnType<typeof postServiceGetMyPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetMyPost>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceGetMyPost>>,
          TError,
          Awaited<ReturnType<typeof postServiceGetMyPost>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceGetMyPost<TData = Awaited<ReturnType<typeof postServiceGetMyPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetMyPost>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/me/posts/{uid} ÂΩìÂâçÁî®Êà∑ÁöÑÂ∏ñÂ≠êËØ¶ÊÉÖÔºàÂê´ PRIVATEÔºâ
 */

export function usePostServiceGetMyPost<TData = Awaited<ReturnType<typeof postServiceGetMyPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetMyPost>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostServiceGetMyPostQueryOptions(uid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary GET /api/v1/posts ÂàóË°®ÔºàÂÖ¨ÂºÄÔºâ
 */
export const postServiceListPosts = (
    params?: PostServiceListPostsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostListPostsResponse>(
      {url: `/api/v1/posts`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getPostServiceListPostsQueryKey = (params?: PostServiceListPostsParams,) => {
    return [
    `/api/v1/posts`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getPostServiceListPostsQueryOptions = <TData = Awaited<ReturnType<typeof postServiceListPosts>>, TError = ErrorType<RpcStatus>>(params?: PostServiceListPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostServiceListPostsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postServiceListPosts>>> = ({ signal }) => postServiceListPosts(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postServiceListPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostServiceListPostsQueryResult = NonNullable<Awaited<ReturnType<typeof postServiceListPosts>>>
export type PostServiceListPostsQueryError = ErrorType<RpcStatus>


export function usePostServiceListPosts<TData = Awaited<ReturnType<typeof postServiceListPosts>>, TError = ErrorType<RpcStatus>>(
 params: undefined |  PostServiceListPostsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceListPosts>>,
          TError,
          Awaited<ReturnType<typeof postServiceListPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceListPosts<TData = Awaited<ReturnType<typeof postServiceListPosts>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceListPosts>>,
          TError,
          Awaited<ReturnType<typeof postServiceListPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceListPosts<TData = Awaited<ReturnType<typeof postServiceListPosts>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/posts ÂàóË°®ÔºàÂÖ¨ÂºÄÔºâ
 */

export function usePostServiceListPosts<TData = Awaited<ReturnType<typeof postServiceListPosts>>, TError = ErrorType<RpcStatus>>(
 params?: PostServiceListPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceListPosts>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostServiceListPostsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary POST /api/v1/posts ÂàõÂª∫Â∏ñÂ≠ê
 */
export const postServiceCreatePost = (
    postCreatePostRequest: PostCreatePostRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostCreatePostResponse>(
      {url: `/api/v1/posts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postCreatePostRequest, signal
    },
      options);
    }
  


export const getPostServiceCreatePostMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceCreatePost>>, TError,{data: PostCreatePostRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postServiceCreatePost>>, TError,{data: PostCreatePostRequest}, TContext> => {

const mutationKey = ['postServiceCreatePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postServiceCreatePost>>, {data: PostCreatePostRequest}> = (props) => {
          const {data} = props ?? {};

          return  postServiceCreatePost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostServiceCreatePostMutationResult = NonNullable<Awaited<ReturnType<typeof postServiceCreatePost>>>
    export type PostServiceCreatePostMutationBody = PostCreatePostRequest
    export type PostServiceCreatePostMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/posts ÂàõÂª∫Â∏ñÂ≠ê
 */
export const usePostServiceCreatePost = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceCreatePost>>, TError,{data: PostCreatePostRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postServiceCreatePost>>,
        TError,
        {data: PostCreatePostRequest},
        TContext
      > => {
      return useMutation(getPostServiceCreatePostMutationOptions(options), queryClient);
    }
    
/**
 * @summary GET /api/v1/posts/{uid} ËØ¶ÊÉÖ
 */
export const postServiceGetPost = (
    uid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostGetPostResponse>(
      {url: `/api/v1/posts/${uid}`, method: 'GET', signal
    },
      options);
    }
  



export const getPostServiceGetPostQueryKey = (uid: string,) => {
    return [
    `/api/v1/posts/${uid}`
    ] as const;
    }

    
export const getPostServiceGetPostQueryOptions = <TData = Awaited<ReturnType<typeof postServiceGetPost>>, TError = ErrorType<RpcStatus>>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetPost>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostServiceGetPostQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postServiceGetPost>>> = ({ signal }) => postServiceGetPost(uid, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postServiceGetPost>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostServiceGetPostQueryResult = NonNullable<Awaited<ReturnType<typeof postServiceGetPost>>>
export type PostServiceGetPostQueryError = ErrorType<RpcStatus>


export function usePostServiceGetPost<TData = Awaited<ReturnType<typeof postServiceGetPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetPost>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceGetPost>>,
          TError,
          Awaited<ReturnType<typeof postServiceGetPost>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceGetPost<TData = Awaited<ReturnType<typeof postServiceGetPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetPost>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postServiceGetPost>>,
          TError,
          Awaited<ReturnType<typeof postServiceGetPost>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostServiceGetPost<TData = Awaited<ReturnType<typeof postServiceGetPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetPost>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/posts/{uid} ËØ¶ÊÉÖ
 */

export function usePostServiceGetPost<TData = Awaited<ReturnType<typeof postServiceGetPost>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postServiceGetPost>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostServiceGetPostQueryOptions(uid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary DELETE /api/v1/posts/{uid} ËΩØÂà†
 */
export const postServiceDeletePost = (
    uid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostServiceDeletePost200>(
      {url: `/api/v1/posts/${uid}`, method: 'DELETE', signal
    },
      options);
    }
  


export const getPostServiceDeletePostMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceDeletePost>>, TError,{uid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postServiceDeletePost>>, TError,{uid: string}, TContext> => {

const mutationKey = ['postServiceDeletePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postServiceDeletePost>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  postServiceDeletePost(uid,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostServiceDeletePostMutationResult = NonNullable<Awaited<ReturnType<typeof postServiceDeletePost>>>
    
    export type PostServiceDeletePostMutationError = ErrorType<RpcStatus>

    /**
 * @summary DELETE /api/v1/posts/{uid} ËΩØÂà†
 */
export const usePostServiceDeletePost = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceDeletePost>>, TError,{uid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postServiceDeletePost>>,
        TError,
        {uid: string},
        TContext
      > => {
      return useMutation(getPostServiceDeletePostMutationOptions(options), queryClient);
    }
    
/**
 * @summary PATCH /api/v1/posts/{uid} Êõ¥Êñ∞Ê≠£Êñá/Â™í‰Ωì/Ê†áÁ≠æ/ÂèØËßÅÊÄß
 */
export const postServiceUpdatePost = (
    uid: string,
    postServiceUpdatePostBody: PostServiceUpdatePostBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostServiceUpdatePost200>(
      {url: `/api/v1/posts/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: postServiceUpdatePostBody, signal
    },
      options);
    }
  


export const getPostServiceUpdatePostMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceUpdatePost>>, TError,{uid: string;data: PostServiceUpdatePostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postServiceUpdatePost>>, TError,{uid: string;data: PostServiceUpdatePostBody}, TContext> => {

const mutationKey = ['postServiceUpdatePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postServiceUpdatePost>>, {uid: string;data: PostServiceUpdatePostBody}> = (props) => {
          const {uid,data} = props ?? {};

          return  postServiceUpdatePost(uid,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostServiceUpdatePostMutationResult = NonNullable<Awaited<ReturnType<typeof postServiceUpdatePost>>>
    export type PostServiceUpdatePostMutationBody = PostServiceUpdatePostBody
    export type PostServiceUpdatePostMutationError = ErrorType<RpcStatus>

    /**
 * @summary PATCH /api/v1/posts/{uid} Êõ¥Êñ∞Ê≠£Êñá/Â™í‰Ωì/Ê†áÁ≠æ/ÂèØËßÅÊÄß
 */
export const usePostServiceUpdatePost = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceUpdatePost>>, TError,{uid: string;data: PostServiceUpdatePostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postServiceUpdatePost>>,
        TError,
        {uid: string;data: PostServiceUpdatePostBody},
        TContext
      > => {
      return useMutation(getPostServiceUpdatePostMutationOptions(options), queryClient);
    }
    
/**
 * @summary POST /api/v1/posts/{uid}/collect Êî∂ËóèÊàñÂèñÊ∂àÊî∂Ëóè
 */
export const postServiceCollectPost = (
    uid: string,
    postServiceCollectPostBody: PostServiceCollectPostBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostServiceCollectPost200>(
      {url: `/api/v1/posts/${uid}/collect`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postServiceCollectPostBody, signal
    },
      options);
    }
  


export const getPostServiceCollectPostMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceCollectPost>>, TError,{uid: string;data: PostServiceCollectPostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postServiceCollectPost>>, TError,{uid: string;data: PostServiceCollectPostBody}, TContext> => {

const mutationKey = ['postServiceCollectPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postServiceCollectPost>>, {uid: string;data: PostServiceCollectPostBody}> = (props) => {
          const {uid,data} = props ?? {};

          return  postServiceCollectPost(uid,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostServiceCollectPostMutationResult = NonNullable<Awaited<ReturnType<typeof postServiceCollectPost>>>
    export type PostServiceCollectPostMutationBody = PostServiceCollectPostBody
    export type PostServiceCollectPostMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/posts/{uid}/collect Êî∂ËóèÊàñÂèñÊ∂àÊî∂Ëóè
 */
export const usePostServiceCollectPost = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceCollectPost>>, TError,{uid: string;data: PostServiceCollectPostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postServiceCollectPost>>,
        TError,
        {uid: string;data: PostServiceCollectPostBody},
        TContext
      > => {
      return useMutation(getPostServiceCollectPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary POST /api/v1/posts/{uid}/like ÁÇπËµûÊàñÂèñÊ∂àËµû
 */
export const postServiceLikePost = (
    uid: string,
    postServiceLikePostBody: PostServiceLikePostBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostServiceLikePost200>(
      {url: `/api/v1/posts/${uid}/like`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postServiceLikePostBody, signal
    },
      options);
    }
  


export const getPostServiceLikePostMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceLikePost>>, TError,{uid: string;data: PostServiceLikePostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postServiceLikePost>>, TError,{uid: string;data: PostServiceLikePostBody}, TContext> => {

const mutationKey = ['postServiceLikePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postServiceLikePost>>, {uid: string;data: PostServiceLikePostBody}> = (props) => {
          const {uid,data} = props ?? {};

          return  postServiceLikePost(uid,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostServiceLikePostMutationResult = NonNullable<Awaited<ReturnType<typeof postServiceLikePost>>>
    export type PostServiceLikePostMutationBody = PostServiceLikePostBody
    export type PostServiceLikePostMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/posts/{uid}/like ÁÇπËµûÊàñÂèñÊ∂àËµû
 */
export const usePostServiceLikePost = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postServiceLikePost>>, TError,{uid: string;data: PostServiceLikePostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postServiceLikePost>>,
        TError,
        {uid: string;data: PostServiceLikePostBody},
        TContext
      > => {
      return useMutation(getPostServiceLikePostMutationOptions(options), queryClient);
    }
    
/**
 * @summary GET /api/v1/users ÂàóË°®
 */
export const userServiceListUsers = (
    params?: UserServiceListUsersParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserListUsersResponse>(
      {url: `/api/v1/users`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getUserServiceListUsersQueryKey = (params?: UserServiceListUsersParams,) => {
    return [
    `/api/v1/users`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getUserServiceListUsersQueryOptions = <TData = Awaited<ReturnType<typeof userServiceListUsers>>, TError = ErrorType<RpcStatus>>(params?: UserServiceListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceListUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserServiceListUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userServiceListUsers>>> = ({ signal }) => userServiceListUsers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userServiceListUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserServiceListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof userServiceListUsers>>>
export type UserServiceListUsersQueryError = ErrorType<RpcStatus>


export function useUserServiceListUsers<TData = Awaited<ReturnType<typeof userServiceListUsers>>, TError = ErrorType<RpcStatus>>(
 params: undefined |  UserServiceListUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceListUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userServiceListUsers>>,
          TError,
          Awaited<ReturnType<typeof userServiceListUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserServiceListUsers<TData = Awaited<ReturnType<typeof userServiceListUsers>>, TError = ErrorType<RpcStatus>>(
 params?: UserServiceListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceListUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userServiceListUsers>>,
          TError,
          Awaited<ReturnType<typeof userServiceListUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserServiceListUsers<TData = Awaited<ReturnType<typeof userServiceListUsers>>, TError = ErrorType<RpcStatus>>(
 params?: UserServiceListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceListUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/users ÂàóË°®
 */

export function useUserServiceListUsers<TData = Awaited<ReturnType<typeof userServiceListUsers>>, TError = ErrorType<RpcStatus>>(
 params?: UserServiceListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceListUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserServiceListUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary POST /api/v1/users ÂàõÂª∫Áî®Êà∑
 */
export const userServiceCreateUser = (
    userCreateUserRequest: UserCreateUserRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserServiceCreateUser200>(
      {url: `/api/v1/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreateUserRequest, signal
    },
      options);
    }
  


export const getUserServiceCreateUserMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceCreateUser>>, TError,{data: UserCreateUserRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userServiceCreateUser>>, TError,{data: UserCreateUserRequest}, TContext> => {

const mutationKey = ['userServiceCreateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userServiceCreateUser>>, {data: UserCreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  userServiceCreateUser(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UserServiceCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof userServiceCreateUser>>>
    export type UserServiceCreateUserMutationBody = UserCreateUserRequest
    export type UserServiceCreateUserMutationError = ErrorType<RpcStatus>

    /**
 * @summary POST /api/v1/users ÂàõÂª∫Áî®Êà∑
 */
export const useUserServiceCreateUser = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceCreateUser>>, TError,{data: UserCreateUserRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userServiceCreateUser>>,
        TError,
        {data: UserCreateUserRequest},
        TContext
      > => {
      return useMutation(getUserServiceCreateUserMutationOptions(options), queryClient);
    }
    
/**
 * @summary GET /api/v1/users/{uid} ËØ¶ÊÉÖ
 */
export const userServiceGetUser = (
    uid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserGetUserResponse>(
      {url: `/api/v1/users/${uid}`, method: 'GET', signal
    },
      options);
    }
  



export const getUserServiceGetUserQueryKey = (uid: string,) => {
    return [
    `/api/v1/users/${uid}`
    ] as const;
    }

    
export const getUserServiceGetUserQueryOptions = <TData = Awaited<ReturnType<typeof userServiceGetUser>>, TError = ErrorType<RpcStatus>>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserServiceGetUserQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userServiceGetUser>>> = ({ signal }) => userServiceGetUser(uid, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userServiceGetUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserServiceGetUserQueryResult = NonNullable<Awaited<ReturnType<typeof userServiceGetUser>>>
export type UserServiceGetUserQueryError = ErrorType<RpcStatus>


export function useUserServiceGetUser<TData = Awaited<ReturnType<typeof userServiceGetUser>>, TError = ErrorType<RpcStatus>>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userServiceGetUser>>,
          TError,
          Awaited<ReturnType<typeof userServiceGetUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserServiceGetUser<TData = Awaited<ReturnType<typeof userServiceGetUser>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userServiceGetUser>>,
          TError,
          Awaited<ReturnType<typeof userServiceGetUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserServiceGetUser<TData = Awaited<ReturnType<typeof userServiceGetUser>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary GET /api/v1/users/{uid} ËØ¶ÊÉÖ
 */

export function useUserServiceGetUser<TData = Awaited<ReturnType<typeof userServiceGetUser>>, TError = ErrorType<RpcStatus>>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userServiceGetUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserServiceGetUserQueryOptions(uid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary DELETE /api/v1/users/{uid} Âà†Èô§ÔºàËΩØÂà†Ôºâ
 */
export const userServiceDeleteUser = (
    uid: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserServiceDeleteUser200>(
      {url: `/api/v1/users/${uid}`, method: 'DELETE', signal
    },
      options);
    }
  


export const getUserServiceDeleteUserMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceDeleteUser>>, TError,{uid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userServiceDeleteUser>>, TError,{uid: string}, TContext> => {

const mutationKey = ['userServiceDeleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userServiceDeleteUser>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  userServiceDeleteUser(uid,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UserServiceDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof userServiceDeleteUser>>>
    
    export type UserServiceDeleteUserMutationError = ErrorType<RpcStatus>

    /**
 * @summary DELETE /api/v1/users/{uid} Âà†Èô§ÔºàËΩØÂà†Ôºâ
 */
export const useUserServiceDeleteUser = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceDeleteUser>>, TError,{uid: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userServiceDeleteUser>>,
        TError,
        {uid: string},
        TContext
      > => {
      return useMutation(getUserServiceDeleteUserMutationOptions(options), queryClient);
    }
    
/**
 * @summary PATCH /api/v1/users/{uid} Êõ¥Êñ∞
 */
export const userServiceUpdateUser = (
    uid: string,
    userServiceUpdateUserBody: UserServiceUpdateUserBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserUpdateUserResponse>(
      {url: `/api/v1/users/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userServiceUpdateUserBody, signal
    },
      options);
    }
  


export const getUserServiceUpdateUserMutationOptions = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceUpdateUser>>, TError,{uid: string;data: UserServiceUpdateUserBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userServiceUpdateUser>>, TError,{uid: string;data: UserServiceUpdateUserBody}, TContext> => {

const mutationKey = ['userServiceUpdateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userServiceUpdateUser>>, {uid: string;data: UserServiceUpdateUserBody}> = (props) => {
          const {uid,data} = props ?? {};

          return  userServiceUpdateUser(uid,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UserServiceUpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof userServiceUpdateUser>>>
    export type UserServiceUpdateUserMutationBody = UserServiceUpdateUserBody
    export type UserServiceUpdateUserMutationError = ErrorType<RpcStatus>

    /**
 * @summary PATCH /api/v1/users/{uid} Êõ¥Êñ∞
 */
export const useUserServiceUpdateUser = <TError = ErrorType<RpcStatus>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userServiceUpdateUser>>, TError,{uid: string;data: UserServiceUpdateUserBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userServiceUpdateUser>>,
        TError,
        {uid: string;data: UserServiceUpdateUserBody},
        TContext
      > => {
      return useMutation(getUserServiceUpdateUserMutationOptions(options), queryClient);
    }
